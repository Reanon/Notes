# B+树

B+ 树是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。

### MySQL 数据库

如何利用散列表、平衡二叉查找树、跳表来实现SQL 语句：

- 根据某个值查找数据，比如 select * from user where id=1234；
- 根据区间值来查找某些数据，比如 select * from user where id > 1234 and id < 2345。

**散列表**：散列表的查询性能很好，时间复杂度是 ==O(1)==。但是，散列表不能支持按照区间快速查找数据。

**平衡二叉查找树**：查询的性能也很高，时间复杂度是 ==O(logn)==。对树进行中序遍历，还可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据。

**跳表**：跳表是在链表之上加上多层索引构成的，支持快速地插入、查找、删除数据，对应的时间复杂度是 ==O(logn)==。

- 跳表也支持按照区间快速地查找数据：只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。
- 数据库索引所用到的数据结构跟跳表非常相似，叫作 **B+ 树**。

![image-20210214100150354](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210214100150.png)

## 改造二叉查找树

为了让二叉查找树支持按照区间来查找数据，可以对它进行这样的改造：

- 树中的节点并不存储数据本身，而是只是作为索引。
- 把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。

看起来很像跳表；如果要求某个区间的数据：

- 只需要拿区间的起始值，在树中进行查找
- 当查找到**某个叶子节点**之后，再顺着链表往后遍历
- 直到链表中的结点数据值大于区间的终止值为止。
- 所有遍历到的数据，就是符合区间值的所有数据。

![image-20210214100610025](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210214100610.png)

### 硬盘存储

要为几千万、上亿的数据构建索引，如果将索引存储在内存中，尽管内存访问的速度非常快，查询的效率非常高，但是，占用的内存会非常多

- 比如：给一亿个数据构建二叉查找树索引，那索引中会包含大约 1 亿个节点，每个节点假设占用 16 个字节，那就需要大约 1GB 的内存空间。
  - 给一张表建立索引，需要 1GB 的内存空间。如果要给 10 张表建立索引，那对内存的需求是无法满足的
- 可以借助时间换空间的思路，把**索引存储在硬盘**中，而非内存中
  - 那么每个节点的读取（或者访问），都对应一次磁盘 IO 操作。
  - 树的高度就等于每次查询数据时磁盘 IO 操作的次数。
  - 比起内存读写操作，磁盘 IO 操作非常耗时，所以优化的重点就是尽量减少磁盘 IO 操作，也就是，**尽量降低树的高度**。
  - 通常内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的（从磁盘中读取花费的时间，是从内存中读取所花费时间的上万倍，甚至几十万倍。）

### 索引构建成 m 叉树

如果根节点存储在内存中，其他结点存储在磁盘中：

- 给 16 个数据 构建**二叉树索引**，树的高度是 4，查找一个数据，就需要 4 个磁盘 IO 操作
- 如果对 16 个数据构建**五叉树索引**，那高度只有 2，查找一个数据，对应只需要 2 次磁盘操作。
- 如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3，最多只要 3 次磁盘 IO 就能获取到数据。

### m 叉树实现 B+ 树索引

假设给 int 类型的数据库字段添加索引，所以代码中的 keywords 是 int 类型的

```java
/**
 * 这是 B+ 树非叶子节点的定义。
 *
 * 假设 keywords=[3, 5, 8, 10]
 * 4 个键值将数据分为 5 个区间：(-INF,3), [3,5), [5,8), [8,10), [10,INF)
 * 5 个区间分别对应：children[0]...children[4]
 *
 * m 值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：
 * PAGE_SIZE = (m-1)*4[keywordss 大小]+m*8[children 大小]
 */
public class BPlusTreeNode {
    public static int m = 5; // 5 叉树
    public int[] keywords = new int[m-1]; // 键值，用来划分数据区间
    public BPlusTreeNode[] children = new BPlusTreeNode[m];// 保存子节点指针
}

/**
 * 这是 B+ 树中叶子节点的定义。
 *
 * B+ 树中的叶子节点跟内部结点是不一样的,
 * 叶子节点存储的是值，而非区间。
 * 这个定义里，每个叶子节点存储 3 个数据行的键值及地址信息。
 *
 * k 值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：
 * PAGE_SIZE = k*4[keyw.. 大小]+k*8[dataAd.. 大小]+8[prev 大小]+8[next 大小]
 */
public class BPlusTreeLeafNode {
    public static int k = 3;
    public int[] keywords = new int[k]; // 数据的键值
    public long[] dataAddress = new long[k]; // 数据地址

    public BPlusTreeLeafNode prev; // 这个结点在链表中的前驱结点
    public BPlusTreeLeafNode next; // 这个结点在链表中的后继结点
}
```

不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。

- 如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。
- 所以，在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。
- 读取一个节点，只需要一次磁盘 IO 操作。

![image-20210214104254643](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210214104254.png)

## B+ 树 

B+ 树的结构和操作，跟跳表非常类似。理论上讲，对跳表稍加改造，也可以替代 B+ 树，作为数据库的索引实现的。

B+ 树的特点：

- 每个节点中子节点的个数不能超过 m，也不能小于 m/2；
- 根节点的子节点个数可以不超过 m/2，这是一个例外；
- m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；
- 通过==链表将叶子节点串联==在一起，这样可以方便按区间查找；
- 一般情况，**根节点会被存储在内存中，其他节点存储在磁盘中**。

### B + 树 插入

B+ 树来说，m 值是根据页的大小事先计算好的，也就是说，每个节点最多只能有 m 个子节点。

某些节点的子节点个数超过 m 时，需要将这个节点分裂成两个节点

- 节点分裂之后，其上层父节点的子节点个数就有可能超过 m 个。可以用同样的方法，将父节点也分裂成两个节点。
- 从下往上，一直影响到根节点

---

图中 B+ 树是一个三叉树：

- 限定叶子节点中，数据的个数超过 2 个就分裂节点；
- 非叶子节点中，子节点的个数超过 3 个就分裂节点

![image-20210214105645166](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210214105645.png)

### B + 树 删除

频繁的数据删除，就会导致某些结点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率。

在 B+ 树中 设置一个阈值为 m/2，如果某个节点的子节点个数小于 m/2，就将它跟相邻的兄弟节点合并。

- 合并之后结点的子节点个数有可能会超过 m。
- 针对这种情况，可以借助插入数据时候的处理方法，再分裂节点。

----

图中的 B+ 树是一个五叉树：

- 限定叶子节点中，数据的个数少于 2 个就合并节点；
- 非叶子节点中，子节点的个数少于 3 个就合并节点。

![image-20210214105840770](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210214105840.png)

## B- 树

B- 树就是 B 树，英文翻译都是 B-Tree；B 树实际上是低级版的 B+ 树，或者说 B+ 树是 B 树的改进版。

B 树跟 B+ 树的不同点主要集中在这几个地方：

- B+ 树中的节点不存储数据，只是索引，而 B 树中的节点存储数据；
- B 树中的叶子节点并不需要链表来串联。

B 树只是一个每个节点的子节点个数不能小于 m/2 的 m 叉树。