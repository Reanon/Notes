# 堆

堆是一种特殊的树，堆的两点要求：

- 堆是一个完全二叉树；
- 堆中每一个节点的值都必须大于等于，或小于等于其子树中每个节点的值。

## 堆分类

大顶堆：每个节点的值都大于等于子树中每个节点值的堆。

小顶堆：每个节点的值都小于等于子树中每个节点值的堆。

![image-20210208160527549](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208160527.png)



完全二叉树比较适合用数组来存储，因为不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。

数组存储堆：

- 数组中下标为 i 的节点：
  - 左子节点，就是下标为 i∗2 的节点
  - 右子节点就是下标为 i∗2+1 的节点
  - 父节点就是下标为 $\frac{i}{2}$ 的节点。

![image-20210208160620962](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208160621.png)

## 插入元素

往堆中插入一个元素后，需要继续满足堆的两个特性。

如果把新插入的元素放到堆的最后，将不符合堆的特性，需要对堆进行调整使其重新满足堆的特性，这个过程就叫作**堆化**（heapify）。堆化实际上有两种，从下往上和从上往下。

![image-20210208161141108](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208161141.png)

<center> 插入元素后不符合堆的特性

### 从下往上堆化

堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。

- 让新插入的节点与父节点对比大小
  - 如果不满足子节点小于等于父节点的大小关系，就互换两个节点。
- 一直重复这个过程，直到父子节点之间满足 大/小 顶堆的特性 。

这就是 **自下而上** 的堆化

![image-20210208161336582](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208161336.png)



### 代码实现

```java
public class Heap {
    private int[] a; // 数组，从下标 1 开始存储数据
    private int n;  // 堆可以存储的最大数据个数
    private int count; // 堆中已经存储的数据个数

    public Heap(int capacity) {
        a = new int[capacity + 1];
        n = capacity;
        count = 0;
    }

    public void insert(int data) {
        if (count >= n) return; // 堆满了
        ++count;
        a[count] = data;
        int i = count;
        // 自下往上堆化
        while (i/2 > 0 && a[i] > a[i/2]) { 
            // swap() 函数作用：交换下标为 i 和 i/2 的两个元素
            swap(a, i, i/2); 
            i = i/2;
        }
    }
}
```



## 删除堆顶元素

堆的定义 任何节点的值都大于等于（或小于等于）子树节点的值，即 堆顶元素存储的就是堆中数据的最大值或者最小值。

假设构造的是大顶堆，堆顶元素就是最大的元素。当删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后再迭代地删除第二大节点，以此类推，直到叶子节点被删除。

- 不过这种方法有点问题，就是最后堆化出来的堆并不满足完全二叉树的特性。

![image-20210208161649555](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208161649.png)

### 从上往下堆化

将最后一个节点放到堆顶，然后利用同样的父子节点对比方法

- 对于不满足父子节点大小关系的，互换两个节点
- 并且重复进行这个过程
- 直到父子节点之间满足大小关系为止

这就是**从上往下的堆化方法**。

- 因移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。

![image-20210208161923945](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208161924.png)

### 代码实现

针对最大堆的删除操作

```java
public void removeMax() {
    if (count == 0) return -1; // 堆中没有数据
    // 将最后的元素移动到堆顶
    a[1] = a[count];
    --count;
    heapify(a, count, 1);
}

// 自上往下堆化
private void heapify(int[] a, int n, int i) { 
    while (true) {
        int maxPos = i;
        // 比较左右节点与本节点的大小
        if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
        if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
        if (maxPos == i) break; // 如果未发生交换，则退出
        // swap() 函数作用：交换下标为 i 和 i/2 的两个元素
        swap(a, i, maxPos);
        i = maxPos;
    }
}
```



## 时间复杂度分析

一个包含 n 个节点的完全二叉树，树的高度不会超过 $log_2n$。==堆化的过程==是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 O(logn)。

堆中比较重要的两个操作是插入一个数据和删除堆顶元素。这两个操作都要用到==堆化==：

- 插入一个数据的时候，把新插入的数据放到数组的最后，然后**从下往上堆化**；
- 删除堆顶数据的时候，我们把数组中的最后一个元素放到堆顶，然后**从上往下堆化**。
- 所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。

