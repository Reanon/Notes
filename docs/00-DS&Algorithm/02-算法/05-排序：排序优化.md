# 排序优化

几乎所有的编程语言都会提供排序函数，比如 C 语言中 qsort()，C++ STL 中的 sort()、stable_sort()，还有 Java 语言中的 `Collections.sort()`。在平时的开发中，也都是直接使用这些现成的函数来实现业务逻辑中的排序功能。

如果要实现一个通用的、高效率的排序函数，我们应该选择哪种排序算法？先回顾一下之前几种排序算法。

- 线性排序算法的时间复杂度比较低，适用场景比较特殊，通用的排序函数，不能选择线性排序算法。
- 对小规模数据进行排序，可以选择时间复杂度是 O(n2) 的算法。
- 对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。
- 所以，为了兼顾任意规模数据的排序，一般都会首选 时间复杂度是 O(nlogn) 的排序算法来实现排序函数。

![image-20210130085802355](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210130085802.png)



时间复杂度是 O(nlogn) 的排序算法不止一个，有归并排序、快速排序，以及堆排序。

- ==Java 语言采用堆排序实现排序函数==
- C 语言使用快速排序实现排序函数
- 归并排序并不是原地排序算法，空间复杂度是 O(n)，所以使用归并排序的情况并不多。

## 优化快速排序

如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 $O(n^2)$。

- 简而言之，O(n2) 时间复杂度出现的主要原因还是因为**分区点选的不够合理**。
- 最理想的分区点是：**被分区点分开的两个分区中，数据的数量差不多**。

两个比较常用、比较简单的分区算法：三数取中法、 随机法

### 三数取中法

核心思想：==从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点==。

- 这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。
- 但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。

### 随机法

随机法：==每次从要排序的区间中，随机选择一个元素作为分区点==。

- 这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选的很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。

### 递归优化

快速排序是用递归来实现的，递归可能引起堆栈溢出，为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出。有两种解决办法：

- **限制递归深度**：一旦递归过深，超过了我们事先设定的阈值，就停止递归。
- **在堆上模拟实现函数调用栈**：手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。

## 排序函数实例

### C 语言

C 语言中的 qsort() 函数，从名字上看 qsort() 很像是基于快速排序算法实现的，实际上它并不仅仅用了快排这一种算法。

- qsort() 会优先使用「==归并排序==」来排序输入数据：归并排序的空间复杂度是 O(n)，所以对于小数据量的排序，比如 1KB、2KB 等，归并排序额外需要 1KB、2KB 的内存空间。
- 要排序的数据量比较大的时候，qsort() 会改为用「==快速排序算法==」来排序，qsort() 选择「三数取中法」来选择快速排序的分区点。
- 在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为「==插入排序==」
  - qsort() 使用了 **哨兵机制** 来优化插入排序。
  - 因为在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。

### Java 语言

在JDK中，排序相关的主要是两个工具类：

- Arrays.java 和 Collections.java，具体的排序方法是sort()。

注意：Collections.java中的sort()方法是将List转为数组，然后调用 `Arrays.sort()` 方法进行排序，具体代码如下(参看List.sort())：

```java
default void sort(Comparator<? super E> c) {
    // 将 List 转为数组
    Object[] a = this.toArray();
    // 调用Arrays.sort()
    Arrays.sort(a, (Comparator) c);
    ListIterator<E> i = this.listIterator();
    for (Object e : a) {
        i.next();
        i.set((E) e);
    }
}
```

在Arrays类中，sort()有一系列的重载方法，罗列几个典型的Arrays.sort()方法如下:

```java
public static void sort(int[] a) {
   // 基本数据类型，使用快速排序
   DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
 }
public static void sort(long[] a) {
   // 基本数据类型，使用双轴快速排序
   DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
}

public static void sort(Object[] a) {
    if (LegacyMergeSort.userRequested)
      // 归并排序
      legacyMergeSort(a);
    else
      ComparableTimSort.sort(a, 0, a.length, null, 0, 0);
}
```

重载方法虽然多，但是从 被排序的数组所存储的内容 这个维度可以将其分为两类：

1. 存储的数据类型是基本数据类型，使用的是快排排序；在数据量很小的时候，使用的插入排序；
2. 存储的数据类型是Object，使用的是归并排序，在数据量很小的时候，使用的也是插入排序

以上两种场景所用到的排序都是「混合式的排序」，也都是为了追求极致的性能而设计的。另外，第二种排序有个专业的名称，叫：==TimSort==



## O(n) 与 O(n log n)

算法的性能可以通过时间复杂度来分析，但是，这种复杂度分析是比较偏理论的，如果深究的话，实际上时间复杂度并不等于代码实际的运行时间。

时间复杂度代表的是一个增长趋势，如果画成增长曲线图，会发现 O(n2) 比 O(nlogn) 要陡峭，也就是说增长趋势要更猛一些。

在大 O 复杂度表示法中，会省略低阶、系数和常数，也就是说，O(nlogn) 在没有省略低阶、系数、常数之前可能是 O(knlogn + c)，而且 k 和 c 有可能还是一个比较大的数。

- 假设 k=1000，c=200，当对小规模数据（比如 n=100）排序时，n2的值实际上比 knlogn+c 还要小。

```java
// 远大于 10000
knlogn+c = 1000 * 100 * log100 + 200 

n^2 = 100*100 = 10000
```

所以，对于小规模数据的排序，O(n2) 的排序算法并不一定比 O(nlogn) 排序算法执行的时间长。对于小数据量的排序，选择比较简单、不需要递归的==插入排序算法==。