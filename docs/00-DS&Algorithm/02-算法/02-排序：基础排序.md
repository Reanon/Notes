# 基础排序

最经典的且最常用的：

- 冒泡排序、插入排序、<u>选择排序</u>
- 归并排序、<u>快速排序</u>
- 桶排序、计数排序、基数排序

![image-20210116105202441](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210116105202.png)

## 排序算法的执行效率

对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：

1、**最好情况、最坏情况、平均情况时间复杂度**

为什么要区分这三种时间复杂度呢？

- 第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。
- 第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。

2、 **时间复杂度的系数、常数 、低阶**

时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。

但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。

3、**比较次数和交换（或移动）次数**

基于比较的排序算法的执行过程，会涉及两种操作：

- ==元素比较大小==
- ==元素交换或移动==。

所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。



## 排序算法的内存消耗

算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，**原地排序（Sorted in place）**。

- ==原地排序算法，就是特指空间复杂度是 O(1) 的排序算法==。
- 冒泡排序、插入排序、选择排序三种排序算法，都是原地排序算法。



## 排序算法的稳定性

仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标——**稳定性**。

- 稳定性：==如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变==。

![image-20210116113927780](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210116114059.png)



比如：有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。这组数据里有两个 3。

- 经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作**稳定的排序算法**；
- 如果前后顺序发生变化，那对应的排序算法就叫作**不稳定的排序算法**。

## 冒泡排序（Bubble Sort）

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。

==一次冒泡会让至少一个元素移动到它应该在的位置==，重复 n 次，就完成了 n 个数据的排序工作。

对一组数据 4，5，6，3，2，1，从小到到大进行排序。第一次冒泡操作的详细过程就是这样：

- 可以看出，经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。
- 要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。

![image-20210116110131393](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210116110131.png)



冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了：

![image-20210116110504967](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210116110505.png)

### 冒泡排序实现

```java
// 冒泡排序，a 表示数组，n 表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```



1、**冒泡排序是原地排序算法**

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，==是一个原地排序算法==。



2、**冒泡排序是稳定的排序算法**

在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换；相同大小的数据在排序前后不会改变顺序，所以==冒泡排序是稳定的排序算法==。



3、**冒泡排序的时间复杂度**

- 最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，时间复杂度是 `O(n)`。
- 而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 `O(n2)`

平均时间复杂度就是加权平均期望时间复杂度。

### 有序度和逆序度

**有序度**是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：

```
有序元素对：a[i] <= a[j], 如果 i < j。
```

![image-20210116111033150](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210116111033.png)



对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是**n\*(n-1)/2**，也就是 15。完全有序的数组的有序度叫作**满有序度**。



**逆序度**的定义正好跟有序度相反（默认从小到大为有序）：

```
逆序元素对：a[i] > a[j], 如果 i < j。
```



**逆序度 = 满有序度 - 有序度**。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

- 例如：要排序的数组的初始状态是 4，5，6，3，2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。n=6，所以排序完成之后终态的**满有序度**为 n*(n-1)/2=15。



冒泡排序包含两个操作原子，**比较和交换**。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为**逆序度**，也就是 `n*(n-1)/2 – 初始有序度` 。

- 对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？
  - 最坏情况下，初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换。
  - 最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。
  - 平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)

## * 插入排序（Insertion Sort）

将数组中的数据分为两个区间，**已排序区间**和**未排序区间**。

- 初始已排序区间只有一个元素，就是数组的第一个元素。

==插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序==。重复这个过程，直到未排序区间中元素为空，算法结束。



例如：要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间；

![image-20210116111938607](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210116111938.png)



插入排序也包含两种操作，一种是**元素的比较**，一种是**元素的移动**。

- 当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。
- 找到插入点之后，我们还需要==将插入点之后的元素顺序往后移动一位==，这样才能腾出位置给元素 a 插入。

对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但==对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度==。

- 满有序度是 n*(n-1)/2=15，初始序列的有序度是 5，所以<u>逆序度是 10</u>。插入排序中，数据移动的个数总和也等于 10=3+3+4。

![image-20210116112218066](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210116112218.png)

### * 插入排序实现

- 从第 2 个元素开始遍历，即 a[1]
- 使 j 记录有序区间的下标
  - 当a[j] 大于待插入的值，则后移 a[j]
  - 当a[j] 小于待插入的值，则将待插入的值插入在a[j]之后

```java
// 插入排序，a 表示数组，n 表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;
  // 从 1 开始， 即第一个元素在已排序区间中，从第2个元素开始搜索
  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    for (; j >= 0; --j) {
      // 前一个元素大于 待插入元素 则后移
      if (a[j] > value) {
        a[j+1] = a[j];  // 后移 a[j]
      } else {
        break;
      }
    }
    // 此时 array[j] < value 或 j = -1
    // 将待插入值插入到array[j]后
    a[j+1] = value; // 插入数据
  }
}
```



1、**插入排序是原地排序算法**

从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也即==是一个原地排序算法==。

2、**插入排序是稳定的排序算法**

在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以==插入排序是稳定的排序算法==

3、**插入排序的时间复杂度**

- 最好情况下时间复杂度为 `O(n)`：排序的数据已经是有序的，我们并不需要搬移任何数据。注意，这里是**从尾到头遍历已经有序的数据**。
- 最坏情况时间复杂度为 `O(n2)`：数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据
- 平均情况时间复杂度 `O(n2)`：数组中插入一个数据的平均时间复杂度是 O(n)；插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作。



## 选择排序（Selection Sort）

选择排序算法的实现思路有点类似插入排序，也分**已排序区间**和**未排序区间**。但是选择排序==每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾==。



![image-20210116113307097](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210116113307.png)



选择排序空间复杂度为 O(1)，是一种==原地排序算法==。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。选择排序是==不稳定的排序算法==。

- 选择排序是一种不稳定的排序算法。从上图中可以看出，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。
- 比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，**相对于冒泡排序和插入排序，选择排序就稍微逊色**了。



## 插入排序优于冒泡排序

问题：插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们**更倾向于使用插入排序算法**而不是冒泡排序算法呢？

答：冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的**逆序度**。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的**逆序度**。

但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：

```java
// 冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换次数 = 逆序度
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}
 
// 插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动 = 逆序度
} else {
  break;
}
```

执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。

- 用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。
- 而插入排序中数据移动操作只需要 K 个单位时间。

虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n2)，但是如果我们希望把性能优化做到极致，那肯定==首选插入排序==。



### 性能测试

随机生成 10000 个数组，在上分别用冒泡和插入排序算法来排序，冒泡排序算法大约 147ms 才能执行完成，而插入排序只需要 16ms 左右就能搞定！

```java
public class Sort {
    public static void main(String[] args) {
        // 记录运行时间
        long start = System.currentTimeMillis();
        int[] array = new int[10000];
        Random random = new Random();
        for (int i = 0; i < array.length; i++) {
            // 生成 1到100之间的随机数
            array[i] = random.nextInt(10000);
        }
        //bubbleSort(array); // 147ms
        insertSort(array); // 17ms
        long end = System.currentTimeMillis();
        System.out.println("排序所用时间: " + (end - start) + "ms");
        System.out.println(Arrays.toString(array));
    }

    public static void insertSort(int[] array) {
        int length = array.length;
        if (length <= 1) {
            return;
        }
        // 从 1 开始， 即第一个元素在已排序区间中，从第2个元素开始搜索
        for (int i = 1; i < length; i++) {
            int value = array[i];
            int j = i - 1;
            for (; j >= 0; j--) {
                // 前一个元素大于 待插入元素 则后移
                if (array[j] > value) {
                    array[j + 1] = array[j];
                } else {
                    break;
                }
            }
            // 此时 array[j] < value 或 j = -1
            // 将待插入值插入到array[j]后
            array[j + 1] = value;
        }
    }

    public static void bubbleSort(int[] array) {
        int length = array.length;
        if (length <= 1) {
            return;
        }
        for (int i = 0; i < length; i++) {
            // 提前退出冒泡循环的标志位
            boolean flag = false;
            // 每冒泡一次，就会有一个元素排号序
            for (int j = 0; j < length - i - 1; j++) {
                // 交换
                if (array[j] > array[j + 1]) {
                    int tem = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = tem;
                    // 表示有数据交换
                    flag = true;
                }
            }
            // 没有数据交换，提前退出
            if (!flag) {
                break;
            }
        }
    }
}
```



## 总结

插入排序 > 冒泡排序 > 选择排序

- 其中 选择排序 是不稳定排序。

![image-20210116113927780](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210116114059.png)

