# 堆排序

排序有时间复杂度是 $O(n^2)$的冒泡排序、插入排序、选择排序，有时间复杂度是 O(nlogn) 的归并排序、快速排序，还有线性排序。

借助于堆这种数据结构实现的排序算法，就叫作==堆排序==。时间复杂度非常稳定，是 O(nlogn)，并且它还是原地排序算法。

堆排序的过程大致分解成两个大的步骤，**建堆**和**排序**。

## 建堆

首先将数组原地建成一个堆。所谓 原地 就是，不借助另一个数组，就在原数组上操作。

建堆的过程，有两种思路：

### 从下往上堆化

借助 在堆中**插入元素**的思路：

- 尽管数组中包含 n 个数据，可以假设起初堆中只包含一个数据，就是下标为 1 的数据。
- 然后，调用 堆插入操作，将下标从 2 到 n 的数据依次插入到堆中。
- 这样就将包含 n 个数据的数组，组织成了堆。

这种建堆思路的处理过程是**从前往后**处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。

### 从上往下堆化

从后往前处理数组，并且每个数据都是从上往下堆化；叶子节点往下堆化只能自己跟自己比较，所以直接从第一个非叶子节点开始依次堆化。

![image-20210208164539199](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208164539.png)

#### 代码实现

在这段代码中，我们对下标从 $\frac{n}{2}$ 开始到 1 的数据进行堆化

- 对于完全二叉树来说，下标从 $\frac{n}{2}+1$ 到 n 的节点是叶子节点，不需要堆化。

```java
private static void buildHeap(int[] a, int n) {
    // 从第一个非叶节点进行堆化
    for (int i = n/2; i >= 1; --i) {
        // 对 i 进行自上而下的堆化
        heapify(a, n, i);
    }
}

private static void heapify(int[] a, int n, int i) {
    while (true) {
        int maxPos = i;
        if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
        if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
        if (maxPos == i) break;
        swap(a, i, maxPos);
        i = maxPos;
    }
}
```

### 时间复杂度

每个节点堆化的时间复杂度是 O(logn)，对 $\frac{n}{2}$ +1  个节点堆化的总时间复杂度并不只是就是 O(nlogn)。

其实堆排序的建堆过程的时间复杂度是 ==O(n)==。

- 因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。
- 每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 k 成正比
- 只需要将==每个节点的高度求和，得出的就是建堆的时间复杂度==。

![image-20210208165138404](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208165138.png)

将每个非叶子节点的高度求和，就是下面这个公式：

![image-20210208165201984](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208165202.png)

- 把公式左右都乘以 2，就得到另一个公式 S2。
- 将 S2 错位对齐，并且用 S2 减去 S1，可以得到 S。

![image-20210208165243787](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208165243.png)

S 的中间部分是一个等比数列，所以最后可以用等比数列的求和公式来计算：

- 因为完全二叉树 h= $log_2n$，代入公式 S，就能得到 S=O(n)
- 所以，建堆的时间复杂度就是 ==O(n)==。

![image-20210208165330818](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208165330.png)

## 排序

建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。

这个过程类似于 **删除堆顶元素** 的操作：

- 当堆顶元素移除之后，把下标为 n 的元素放到堆顶
- 然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆
- 堆化完成之后，再取堆顶的元素，放到下标是 n−1 的位置
- 一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。

![image-20210208165651906](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208165652.png)

### 代码实现

```java
// n 表示数据的个数，数组 a 中的数据从下标 1 到 n 的位置。
public static void sort(int[] a, int n) {
  buildHeap(a, n);
  int k = n;
  while (k > 1) {
    swap(a, 1, k);
    --k;
    heapify(a, k, 1);
  }
}
```

## 复杂度分析

### 空间复杂度

整个堆排序的过程，都只需要极个别临时存储空间，堆排序是原地排序算法，空间复杂度为 O(1)。

### 时间复杂度

堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 **O(n)**，排序过程的时间复杂度是 **O(nlogn)**。

所以，堆排序整体的时间复杂度是 ==O(nlogn)==。

### 稳定度分析

==堆排序不是稳定的排序算法==，因为在排序的过程，存在将堆的<u>最后一个节点跟堆顶节点</u>互换的操作，所以就有可能改变值相同数据的原始相对顺序。



## 快速排序与堆排序

快速排序性能比堆排序性能好，主要有两方面的原因：

1、堆排序数据访问的方式没有快速排序友好

快速排序的数据是顺序访问的；而堆排序的数据是跳着访问的。堆排序中，最重要的一个操作就是数据的堆化。

- 比如下面这个例子，对堆顶节点进行堆化，会依次访问数组下标是 1，2，4，8 的元素；而不是像快速排序那样，局部顺序访问，所以，这样对 CPU 缓存是不友好的。

![image-20210208171826004](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208171826.png)

2、对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序

排序有提到 有序度和逆序度。对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。==快速排序数据交换的次数不会比逆序度多==。

但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。

- 比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。

![image-20210208172224745](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208172224.png)



## 堆的应用

堆这种数据结构几个非常重要的应用：优先级队列、求 Top K 和求中位数。

### 优先级队列

队列最大的特性就是先进先出。不过，在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。

用堆来实现优先级队列是最直接、最高效的，因为堆和优先级队列非常相似，一个堆就可以看作一个优先级队列。

- 往优先级队列中插入一个元素，就相当于往堆中插入一个元素；
- 从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。

很多数据结构和算法都要依赖优先级队列：比如，赫夫曼编码、图的最短路径、最小生成树算法等等。

- 很多语言中，都提供了优先级队列的实现，比如，Java 的 PriorityQueue，C++ 的 priority_queue 等。

#### 合并有序小文件

假设有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。希望将这些 100 个小文件合并成一个有序的大文件。这里就会用到优先级队列。

整体思路有点像归并排序中的合并函数：

- 从这 100 个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除
- 假设这个最小的字符串来自于 13.txt 这个小文件，就再从这个小文件取下一个字符串，并且放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，并且将它从数组中删除。
- 依次类推，直到所有的文件中的数据都放入到大文件为止。

这里用数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。

这里就可以用到优先级队列，也就是堆：

- 将从小文件中取出来的字符串放入到小顶堆中
- 那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。将堆顶字符串放入到大文件中，并将其从堆中删除。
- 再从小文件中取出下一个字符串，放入到堆中。
- 循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。

删除堆顶数据和往堆中插入数据的时间复杂度都是 ==O(logn)==，n 表示堆中的数据个数，这里就是 100。

#### 高性能定时器

假设有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。

但是，这样每过 1 秒就扫描一遍任务列表的做法比较低效，主要原因有两点：

- 第一，任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；
- 第二，每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。

针对这些问题，就可以用==优先级队列==来解决：

- 按照任务设定的执行时间，将这些任务存储在优先级队列中
- 队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务。

这样，定时器就不需要每隔 1 秒就扫描一遍任务列表了。它拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。

- 这个时间间隔 T 就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。这样，定时器就可以设定在 T 秒之后，再来执行任务。从当前时间点到（T-1）秒这段时间里，定时器都不需要做任何事情。
- 当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。
- 然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。

### 利用堆求 Top K

堆的另外一个非常重要的应用场景，那就是“求 Top K 问题”

求 Top K 的问题抽象成两类：

- 一类是针对静态数据集合：也就是说数据集合事先确定，不会再变。
- 另一类是针对动态数据集合：也就是说数据集合事先并不确定，有数据动态地加入到集合中。

#### 静态数据

针对静态数据，如何在一个包含 n 个数据的数组中，查找前 K 大数据：

- 可以维护一个大小为 K 的**小顶堆**，顺序遍历数组，从数组中取出取数据与堆顶元素比较
- 如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；
- 如果比堆顶元素小，则不做处理，继续遍历数组。
- 等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了

遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(log K) 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，所以时间复杂度就是 ==O(nlogK)==

#### 动态数据

针对动态数据求得 Top K 就是实时 Top K；此时数据集合中有两个操作，一个是添加数据，另一个询问当前的前 K 大数据。

如果每次询问前 K 大数据，都基于当前的数据重新计算的话，那时间复杂度就是 O(nlogK)，n 表示当前的数据的大小。

实际上，可以一直都维护一个 K 大小的 **小顶堆**，当有数据被添加到集合中时，就拿它与堆顶的元素对比。

- 如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；
- 如果比堆顶元素小，则不做处理。

这样，无论任何时候需要查询当前的前 K 大数据，都可以立刻返回。

### 利用堆求中位数

如何求动态数据集合中的中位数：

中位数，顾名思义，就是处在中间位置的那个数。

- 如果数据的个数是奇数，把数据从小到大排列，那第 $\frac{n}{2} + 1$个数据就是中位数；
- 如果数据的个数是偶数的话，那处于中间位置的数据有两个，第 $\frac{n}{2}$ 个和第 $\frac{n}{2} + 1$  个数据，这个时候，可以随意取一个作为中位数，比如取两个数中靠前的那个，就是第 $\frac{n}{2}$  个数据。

![image-20210208220133400](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208220133.png)

#### 静态数据

对于一组**静态数据**，中位数是固定的，可以先排序，第 $\frac{n}{2}$个数据就是中位数。

- 每次询问中位数的时候，直接返回这个固定的值就好了。所以，尽管排序的代价比较大，但是边际成本会很小。

#### 动态数据

如果面对的是**动态数据**集合，中位数在不停地变动；如果再用先排序的方法，每次询问中位数的时候，都要先进行排序，那效率就不高了。可以借助堆这种数据结构，可以不用排序，就可以非常高效地实现求中位数操作；

需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且==小顶堆中的数据都大于大顶堆中的数据==。也就是说：

- 如果有 n 个数据，n 是偶数：
  - 从小到大排序，那前 $\frac{n}{2}$ 个数据存储在**大顶堆**中，后 $\frac{n}{2}$ 个数据存储在**小顶堆**中。
  - 这样，**大顶堆中的堆顶元素**就是要找的中位数。
- 如果 n 是奇数：
  - 大顶堆就存储 $\frac{n}{2} + 1$ 个数据，小顶堆中就存储 $\frac{n}{2}$ 个数据。
  - **大顶堆中的堆顶元素**就是要找的中位数

![image-20210208220606657](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208220606.png)

当新添加一个数据的时候：

- 如果新加入的数据 小于等于大顶堆 的堆顶元素，就将这个新数据插入到大顶堆；
- 如果新加入的数据 大于等于小顶堆 的堆顶元素，就将这个新数据插入到小顶堆。

如果此时 两个堆中的数据个数不符合前面约定的情况，即：

- 如果 n 是偶数，两个堆中的数据个数都是 $\frac{n}{2}$；
- 如果 n 是奇数，大顶堆有 $\frac{n}{2} + 1$  个数据，小顶堆有 $\frac{n}{2}$  个数据。

可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。

![image-20210208221008055](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208221008.png)

于是，就可以利用两个堆，一个大顶堆、一个小顶堆，实现在动态数据集合中求中位数的操作。

- 插入数据因为需要涉及堆化，所以时间复杂度变成了 ==O(logn)==
- 但是求中位数我们只需要返回**大顶堆的堆顶元素**就可以了，所以时间复杂度就是 O(1)。

### 求  99 百分位数

99 百分位数的概念可以类比中位数，如果将一组数据从小到大排列，这个 99 百分位数就是大于前面 99% 数据的那个数据。

- 假设有 100 个数据，分别是 1，2，3，……，100，那 99 百分位数就是 99，因为小于等于 99 的数占总个数的 99%。

![image-20210208221408520](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208221408.png)

可以维护两个堆，一个大顶堆，一个小顶堆。

- 假设当前总数据的个数是 n，大顶堆中保存 n * 99% 个数据
- 小顶堆中保存 n*1% 个数据。
- **大顶堆堆顶的数据** 就是要找的 99% 数。

每次插入一个数据的时候，要判断这个数据跟大顶堆和小顶堆堆顶数据的大小关系，然后决定插入到哪个堆中

- 如果这个新插入的数据比大顶堆的堆顶数据小，那就插入大顶堆；
- 如果这个新插入的数据比小顶堆的堆顶数据大，那就插入小顶堆。

为了保持大顶堆中的数据占 99%，小顶堆中的数据占 1%，在每次新插入数据之后，都要重新计算，这个时候大顶堆和小顶堆中的数据个数，是否还符合 99:1 这个比例。

- 如果不符合，就将一个堆中的数据移动到另一个堆，直到满足这个比例。

每次插入数据，可能会涉及几个数据的堆化操作，所以时间复杂度是 **O(logn)**。每次求 99% 响应时间的时候，直接返回大顶堆中的堆顶数据即可，时间复杂度是 **O(1)**。