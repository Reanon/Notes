# 字符串匹配基础

字符串查找函数底层依赖就是字符串匹配算法，比如 Java 中的 indexOf()，Python 中的 find() 函数等。

字符串匹配算法很多：

- 一个串跟一个串进行匹配的单模式串匹配，相应算法BF 算法、 RK 算法、BM 算法和 KMP 算法
- 一个串中同时查找多个串的多模式串匹配，相应算法有 **Trie 树**和 **AC 自动机**

## BF 算法

BF 算法中的 BF 是 Brute Force 的缩写，叫作**暴力匹配算法**，也叫朴素匹配算法。

### 主串和模式串

在字符串 A 中查找字符串 B，那字符串 A 就是主串，字符串 B 就是模式串。

- 主串的长度记作 n，模式串的长度记作 m
- 因为是在主串中查找模式串，所以 n>m

### BF算法思想

作为最简单、最暴力的字符串匹配算法，BF 算法的思想：==在主串中检查起始位置分别是 0、1、2… n-m 且长度为 m 的 n-m+1 个子串==，看有没有跟模式串匹配的。

![image-20210209092549386](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210209092549.png)

### 时间复杂度

在极端情况下，比如主串是 aaaaa…aaaaaa ，模式串是 aaaaab 。每次都比对 m 个字符，要比对 n-m + 1 次，所以，BF算法的最坏情况时间复杂度是 ==O(n*m)==

### 应用性分析

尽管理论上BF 算法的时间复杂度很高，是 O(n*m)，但在实际的开发中，它却是一个比较常用的字符串匹配算法：

- 实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。
- 而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把 m 个字符都比对一下。
- 尽管理论上的最坏情况时间复杂度是 O(n*m)，但是，统计意义上，算法执行效率要比这个高很多。
- 朴素字符串匹配算法思想简单，代码实现也非常简单

简单意味着不容易出错，如果有 bug 也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选，也是常说的[KISS（Keep it Simple and Stupid）设计原则](https://zh.wikipedia.org/wiki/KISS原则)。

所以，在实际的软件开发中，绝大部分情况下，**朴素的字符串匹配算法**就够用了

## RK 算法

RK 算法的全称叫 Rabin-Karp 算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的，可以看作BF 算法的升级版。

在BF 算法中，模式串长度为 m，主串长度为 n，那在主串中就会有 **n-m+1** 个长度为 m 的子串，只需要暴力地对比这 n-m+1 个子串与模式串，就可以找出主串与模式串匹配的子串。

- 每次检查主串与子串是否匹配，需要依次比对每个字符，所以 BF 算法的时间复杂度就比较高，是 O(n*m)
- 如果对朴素的字符串匹配算法稍加改造，**引入哈希算法**，时间复杂度立刻就会降低。

### RK算法思想

RK 算法的思路：

- 通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。
  - 如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配。

因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。

![image-20210209093254594](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210209093254.png)

### RK 的哈希算法

假设要匹配的字符串的字符集中只包含 K 个字符，可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。 

- 比如：要处理的字符串只包含 a～z 这 26 个小写字母，那就用二十六进制数来表示字符串，也即把a～z 依次映射到 0～25。 
- 计算哈希的时候，只需要把进位从 10 改成 26 就可以。

![image-20210209093542256](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210209093542.png)

这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系：

- 相邻两个子串 s[i-1] 和 s[i]（i 表示子串在主串中的起始位置，子串的长度都为 m），对应的哈希值计算公式有交集，也就是说，可以使用 s[i-1] 的哈希值很快的计算出 s[i] 的哈希值。

![image-20210209093957263](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210209093957.png)

可以通过查表的方法来提高计算26^(m-1) 这部分的效率：

- 事先计算好 26^0 、26^1、 26^2 ……26^(m-1)，并且存储在一个长度为 m 的数组中，公式中的“次方”就对应数组的下标
- 当需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间

![image-20210209094200703](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210209094200.png)

#### 哈希冲突

本哈希算法是没有散列冲突的，也即一个字符串与一个二十六进制数相对应，不同的字符串的哈希值肯定不一样。

- 存在的问题：当模式串很长，哈希值就可能超过了计算机中整型数据可以表示的范围。

为了避免整数溢出，可以修改哈希算法允许出现哈希冲突，比如使用 1~26 对应字符串中只包含 a～z 英的文字母，可以把字符串中每个字母对应的数字相加，最后得到的和作为哈希值。

- 发现一个子串的哈希值跟模式串的哈希值相等的时候，只需要再对比一下子串和模式串本身就好。
- 当然，如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也不匹配的。

哈希算法如果存在大量冲突，就会导致 RK 算法的时间复杂度退化，效率下降。RK算法时间复杂度就会退化成 O(n*m)。一般情况下，冲突不会很多，RK 算法的效率还是比 BF 算法高的。



### 时间复杂度

整个 RK 算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较：

- 可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值，计算子串哈希值这部分的时间复杂度是 O(n)
- 模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 O(1)，总共需要比较 n-m+1 个子串的哈希值，所以哈希值比骄傲的时间复杂度也是 O(n)。

RK 算法整体的时间复杂度就是 ==O(n)==。

