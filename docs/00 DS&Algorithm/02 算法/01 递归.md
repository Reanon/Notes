# 基础算法：递归

递归（Recursion）是一种应用非常广泛的算法（或者编程技巧）。很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等等。

基本上，所有的递归问题都可以用递推公式来表示，例如：f(n)=f(n-1)+1，其中，f(1)=1。有了这个递推公式，就可以很轻松地将它改为递归代码：

```java
int f(int n) {
  if (n == 1) return 1;
  return f(n-1) + 1;
}
```

### 递归的三个条件

问题同时满足以下三个条件，就可以用递归来解决：

1、==一个问题的解可以分解为几个子问题的解==

- **子问题**就是数据规模更小的问题。比如，电影院的例子，你要知道“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。

2、==这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样==

- 比如电影院那个例子，你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。

3、==存在递归终止条件==

- 把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。
- 电影院的例子中，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1)=1，这就是递归的终止条件。

### 编写递归代码

递归代码最关键的是**写出递推公式，找到终止条件**，剩下将递推公式转化为代码。即：

1. 如何将大问题**分解**为小问题的规律
2. 并且基于此写出**递推公式**
3. 然后再推敲**终止条件**
4. 最后将递推公式和终止条件**翻译成代码**

> 只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，**不要试图用人脑去分解递归的每个步骤**

#### N 台阶问题

假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？

**1、递推公式**

仔细想下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。

- 所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法  +  先走 2 阶后，n-2 个台阶的走法，用公式表示就是：`f(n) = f(n-1)+f(n-2)`

**2、终止条件**

有了递推公式，递归代码基本上就完成了一半。我们再来看下终止条件。

- 当有一个台阶时，我们不需要再继续递归，就只有一种走法， f(1)=1。

这个递归终止条件足够吗？我们可以用 n=2，n=3 这样比较小的数试验一下。

- n=2 时，f(2)=f(1)+f(0)。如果递归终止条件只有一个 f(1)=1，那 f(2) 就无法求解了。
- 所以除了 f(1)=1 这一个递归终止条件外，还要有 f(0)=1，表示走 0 个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。
- 所以，我们可以把 f(2)=2 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。

最后，递归终止条件就是 f(1)=1，f(2)=2。这个时候，可以再拿 n=3，n=4 来验证一下，这个终止条件是否足够并且正确。

==递归终止条件和刚刚得到的递推公式放到一起==就是这样的：

```
f(1) = 1;
f(2) = 2;
f(n) = f(n-1)+f(n-2)
```

**3、转化成递归代码**

有了这个公式，转化成递归代码就简单多了。最终的递归代码是这样的：

```java
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
```

#### 思维方式

对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。那正确的思维方式应该是怎样的呢？

如果一个问题 A 可以分解为若干子问题 B、C、D，==可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。==

- 而且，你只需要思考**问题 A 与子问题 B、C、D 两层之间的关系**即可
- 不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。
- 屏蔽掉递归细节，这样子理解起来就简单多了。

### 递归要警惕堆栈溢出

函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。





### 递归代码要警惕重复计算

使用递归时还会出现重复计算的问题。如果我们把整个递归过程分解一下的话，那就是这样的：

![image-20210115171628163](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210115171628.png)

可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。

为了避免重复计算，我们可以通过一个==数据结构（比如散列表）来保存已经求解过的 f(k)==。当递归调用到 f(k) 时，先看下是否已经求解过了：

- 如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。

```java
public int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  // hasSolvedList 可以理解成一个 Map, key是n, value是f(n)
  if (hasSolvedList.containsKey(n)) {
    return hasSovledList.get(n);
  }
  // 未被求解过，就加入结果集中
  int ret = f(n-1) + f(n-2);
  hasSovledList.put(n, ret);
  return ret;
}
```





