

# 红黑树

> 参考：[常见平衡树（2-3树与红黑树原理与实现)](https://kswapd.cn/article/twothreetree-and-rbtree/)、[从2-3树到 红黑树](https://blog.csdn.net/fei33423/article/details/79132930)
>

二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 $log_2n$ 的情况，从而导致各个操作的效率下降。极端情况下，**二叉树会退化为链表**，时间复杂度会退化到 O(n)。

## 平衡二叉树

平衡二叉查找树 有很多，如 Splay Tree（伸展树）、Treap（树堆）等，但提及最多的是 **红黑树**，甚至默认平衡二叉查找树就是红黑树。

### 严格定义

平衡二叉树的**严格定义**：二叉树中任意一个节点的左右子树的高度相差不能大于 1。

- 完全二叉树、满二叉树其实都是平衡二叉树
- 但是非完全二叉树也有可能是平衡二叉树

[AVL 树](https://zh.wikipedia.org/wiki/AVL树)（Adelson-Velsky and Landis Tree）是计算机科学中最早被发明的**自平衡二叉查找树**。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)

很多平衡二叉查找树其实并没有严格满足 「树中任意一个节点的左右子树的高度相差不能大于 1」的条件，比如==红黑树==，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。

### 平衡

**平衡二叉查找树** 的初衷是解决普通二叉查找树在频繁的插入、删除 等动态更新的情况下，出现时间复杂度退化的问题。

所谓 「平衡」即使得 整棵树左右比较对称，不出现左子树很高、右子树很矮的情况，如此使得整棵树的**高度**相对来说低一些，相应的插入、删除、查找等操作的效率高一些。

若 二叉查找树的高度依然 是对数 数量级，即$log_2n$左右，尽管它不符合 严格的平衡二叉查找树的定义，但仍然可以说，这是一个合格的平衡二叉查找树。



### 近似平衡

平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。

- 「==平衡==」可以等价为性能不退化。
- 「==近似平衡==」就等价为性能不会退化的太严重。

## 2-3 查找树

2-3查找树中的 「2-3」 指的是2叉-3叉，2-3树 允许树中的一个结点保存多个键：

- **2-结点**：含有一个键 和两条链接
  - 左链接指向的2-3树中的键都小于该结点
  - 右链接指向的2-3树中的键都大于该结点。

- **3-结点**：含有两个键和三条链接
  - 左链接指向的2-3树中的键都小于该结点
  - 中链接指向的2-3树中的键都位于该结点的两个键之间
  - 右链接指向的2-3树中的键都大于该结点

![image-20210208112526583](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208112526.png)

### 查找 

要判断一个键是否在树中

1. 先将它和根结点中的键比较
   - 如果它和其中的任何一个相等，查找命中。
2. 否则就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。
3. 如果这是个空链接，查找未命中



### 插入过程

要在2-3树中插入一个新结点，可以和二叉查找树一样先进行一次未命中的查找，然后把新结点挂在树的底部。但这样的话树无法保持完美平衡性。使用2-3树的主要原因就在于它能够在插入之后继续保持平衡。

插入过程：

1. 先找插入结点，若结点有空(即2-结点)，则直接插入。
2. 如结点没空(即3-结点)，则插入使其**临时**容纳这个元素，变为4-结点，然后分裂 4- 结点
   - 把中间元素移到其父结点中
   - 对父结点亦如此处理。
3. 中键一直往上移，直到找到空位，在此过程中没有空位就先搞个临时的，再分裂。

#### 2-节点中插入新键

- 在节点中插入，将这个2-节点变成3-节点即可

![image-20210208112839098](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208112839.png)

#### 3-节点的树中插入新键

- 先将数据临时存储在 3-节点 中，这时该节点会变成 **4-节点**。
- 将该 4-节点 分解成 三个 2-节点 组成的二叉查找树
  - 即中键是父节点，左右键分别是左右子节点

![image-20210208112935810](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208112935.png)

#### 父节点为2-节点 的 3-节点中插入新键

1. 将新键插入到3-节点中，此时3-节点变成4-节点。
2. 将 4-节点 的中键移动到父节点中，此时父节点变成3-节点。
3. 并将原来的 2-节点 分解成该父节点的左右两个子节点。

![image-20210208113155108](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208113155.png)

#### 分解根节点

如果出现4-节点一直向上分解的情况，直到根节点，那么将触发根节点分解。

- 此时根节点必为4-节点，直接分解为三个2-节点，此时**树高度加1**。

![image-20210208113315267](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208113315.png)

#### 父节点为3-节点 的 3-节点中插入新键

1. 将 新键插入到3-节点中，此时3-节点变成4-节点。
2. 将该4-节点的中键插入父节点中，此时父节点也变成4-节点，此时原节点变成3-节点。
3. 将原3-节点分解成父节点的左右两个子节点。
4. 将父节点看做原节点，重复2-4过程，直到遇到父节点是2节点，不用再继续向上分解。

![image-20210208113630006](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208113630.png)



例2

 ![img](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208140955.jpeg)



2-3树 插入算法的根本在于这些==变换都是局部==的：

- 除了相关的结点和链接之外不必修改或者检查树的其他部分。
- 每次变换中，变更的链接数量不会超过一个很小的常数。
- 所有局部变换都不会影响整棵树的有序性和平衡性。

### 构造过程

和标准的二叉查找树由上向下生长不同，==2-3树的生长是由下向上的==。

![image-20210208141400595](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208141400.png)

### 2-3 树特点

优点：

2-3树在最坏情况下仍有较好的性能。

- 每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以任何查找或者插入的成本都肯定不会超过对数级别

完美平衡的2-3树要平展的多

- 例如，含有10亿个结点的一颗2-3树的高度仅在19到30之间。
- 最多只需要访问30个结点就能在10亿个键中进行任意查找和插入操作。

劣势：

需要维护两种不同类型的结点，查找和插入操作的实现需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。



## 红黑树

红黑树的英文是 Red-Black Tree，简称 R-B Tree，是一种不严格的平衡二叉查找树；本质上讲 ==红黑树就是用 红链接 表示3-结点的2-3树==，红黑树的插入、构造就可转化为2-3树的问题。

### 2-3树与红黑树

==红黑树其实是起源于2-3树的==，用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树，用**左旋，右旋，变色**这三种基础操作代替了2-3树向上分裂的过程。

将红黑树中的链接分为两种类型：

- **红链接** 将两个2-结点连接起来构成一个3-结点
- **黑链接** 则是2-3树中的普通链接。

确切地说，将3-结点表示为由一条**左斜**的红色链接相连的两个2-结点。

![image-20210208142502298](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208142502.png)



红黑树的另一种定义是满足下列条件的二叉查找树：

1. 红链接均为左链接。
2. 没有任何一个结点同时和两条红链接相连。
3. 该树是完美==黑色平衡==的，即任意空链接到根结点的路径上的黑链接数量相同。

即，将一颗红黑树中的红链接**画平**，那么所有的空链接到根结点的距离都将是相同的。如果我们将由红链接相连的结点合并，得到的就是一颗2-3树。

![image-20210208142707208](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208142707.png)



红黑树都既是二叉查找树，也是2-3树

- 2-3树的深度很小，平衡性好，效率高，但是其有两种不同的结点，实际代码实现比较复杂。
- 红黑树用红链接表示 2-3树中另类的3-结点，统一了树中的结点类型，使代码实现简单化，又不破坏其高效性。

#### 颜色表示

每个结点都只会有一条 父结点指向它的链接，将链接的颜色保存在表示结点的Node数据类型的布尔变量color中

- 若指向它的链接是红色的，那么该变量为true，黑色则为false

当提到一个结点颜色时，指的是==指向该结点的链接的颜色==。

#### 旋转

在实现的某些操作中可能会出现 **红色右链接** 或者 **两条连续的红链接**，但在操作完成前这些情况都会被小心地旋转并修复。

#### 插入

在插入时可以使用 旋转操作来保证2-3树和红黑树之间的一一对应关系

- 因为旋转操作可以保持红黑树的两个重要性质：**有序性**和**完美平衡性**。

##### 2-结点中插入新键

向红黑树中插入操作时，与2-3树的插入操作本质上相同，只是它们对3结点的表示不同

- 向一个只含有一个2-结点的2-3树中插入新键后，2-结点变为3-结点，再把这个 3-结点转化为红结点即可

![image-20210208143736494](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208143736.png)

##### 双键树（3-结点）中插入新键

向2-3树中的一个3-结点插入新键，这个3结点临时成为4-结点，然后分裂成3个2结点。

![image-20210208144113815](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208144113.png)

##### 红黑树的构造全过程

![img](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208144210.png)



### 红黑树 表示

红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：

1. 节点是红色或者黑色
2. ==根节点 是黑色==的；
3. 每个叶子节点都是黑色的空节点（NIL），也就是说，==叶子节点不存储数据==；
   - 主要是为了简化红黑树的代码实现而设置的，
4. 每个红节点的子节点都是黑节点，即==任何路径上不能连续出现两个红节点==
   - 也就是说，红色节点是被黑色节点隔开的；
5. 从任意节点到每个叶子节点都包含相同数目的黑色节点，==黑色平衡==

![image-20210208110003724](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208110003.png)

<center>红黑树 图例





### 红黑树的调整方法

红黑树的处理过程是与2-3树类似，是**自下而上**进行生长，在向上生长的过程中，需要通过==左旋==，==变色==，==右旋==的来不断将树的节点进行调整，维持树的高度，达到平衡。

为了方便调整，假设所有新插入的节点在调整之前均为红色。

#### 左旋

如果当前节点的 右节点是红色，左节点是黑色，那么当前节点需要左旋。

- 这个比较典型的情况是在根节点插入一个大于自己的键的情况下
- 即当前节点小于要插入的节点，就会触发**左旋**。

![image-20210208135303428](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208135303.png)

#### 变色

如果当前节点的左右两个子节点皆为红色的话，那么会触发变色逻辑。

![image-20210208135603419](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208135603.png)



#### 右旋

右旋比较复杂，一般伴随有变色和左旋。

如果当前基准节点的左子节点和左孙子节点都为红色，此时违反了红黑树平衡原则的「任何路径上不能连续出现两个红节点」，此时需要==右旋==解决这种情况。

![image-20210208135751106](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208135751.png)



### 红黑树的近似平衡 

一棵极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是 $log_2n$。

如果要证明红黑树是近似平衡的，则需要分析红黑树的高度是否比较稳定地趋近 $log_2n$ 即可。

### 红黑树的高度

#### 去掉红节点

如果将红色节点从红黑树中去掉，考察红黑树的高度：

- 红色节点删除之后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。
- 之前的二叉树就变成了 **四叉树**

![image-20210208110608423](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208110608.png)



红黑树的定义里有这么一条：==从任意节点到可达的叶子节点的每个路径包含相同数目的黑色节点==。

- 从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。
- 所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小
- 完全二叉树的高度近似 log2n，这里的 **四叉黑树** 的高度要低于完全二叉树，所以去掉红色节点的 黑树 的高度也不会超过 log2n

#### 添加红节点

现在把红色节点加回去，考察红黑树的高度：

- 在红黑树中，红色节点不能相邻：也即，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。
- 红黑树中包含最多黑色节点的路径不会超过 $log_2n$，加入红色节点之后，最长路径不会超过 $2log_2n$，也就是说，红黑树的 高度近似 $2log_2n$。

红黑树的高度只比高度平衡的 AVL 树的高度（log2n）仅仅大了一倍，在性能上，下降得并不多。



### 平衡二叉查找树 比较

Treap、Splay Tree：绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。

AVL 树是一种**高度平衡**的二叉树，所以查找的效率非常高，但AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。

红黑树只是做到了**近似平衡**，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。所以，红黑树的插入、删除、查找各种操作性能都比较稳定。



