# 图

树中的元素我们称为节点，图中的元素我们就叫作**顶点**（vertex）。图中的一个顶点可以与任意其他顶点建立连接关系，这种关系叫作**边**（edge）。

![image-20210208223001574](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208223001.png)

边有方向的图叫作 有向图，边没有方向的图就叫作 无向图 。

无向图中有 度 这个概念，表示一个顶点有多少条边。在有向图中，我们把度分为**入度**（In-degree）和**出度**（Out-degree）。

- 顶点的入度，表示有多少条边指向这个顶点；
- 顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。

![image-20210208223110944](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208223111.png)

在**带权图**（weighted graph）中，每条边都有一个权重（weight）。

![image-20210208223206223](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208223206.png)

## 邻接矩阵存储方法

图最直观的一种存储方法就是，**邻接矩阵**（Adjacency Matrix）

邻接矩阵的底层依赖一个二维数组。

对于**无向图**来说：

- 如果顶点 i 与顶点 j 之间有边，我们就将 A[i] [j] 和 A[j] [i] 标记为 1；

对于**有向图**来说：

- 如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i] [j] 标记为 1。
- 如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j] [i] 标记为 1

对于**带权图**，数组中就存储相应的权重。

![image-20210208223418293](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208223418.png)

邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。

- 其次，用邻接矩阵存储图的另外一个好处是方便计算。
- 用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。比如求解最短路径问题时会提到一个[Floyd-Warshall 算法](https://zh.wikipedia.org/wiki/Floyd-Warshall算法)，就是利用矩阵循环相乘若干次得到结果。

## 邻接表存储方法

**邻接表**（Adjacency List）的每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。

![image-20210208223557557](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210208223557.png)

邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。

- 比如要确定是否存在一条从顶点 2 到顶点 4 的边，那就要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4。

邻接表改进：

- 链表可以改成平衡二叉查找树。实际开发中，可以选择用**红黑树**。
- 二叉查找树可以换成其他动态数据结构，比如跳表、散列表等。
- 除此之外，还可以将链表改成有序动态数组，可以通过二分查找的方法来快速定位两个顶点之间否是存在边。